#!/usr/bin/env node
var path = require('path');
var arg = require('arg');
var fs = require('fs');
var fsp = require('fs/promises');
require('rimraf');
var require$$0 = require('tty');
var bunchee = require('bunchee');
require('module');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var path__default = /*#__PURE__*/_interopDefault(path);
var arg__default = /*#__PURE__*/_interopDefault(arg);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var fsp__default = /*#__PURE__*/_interopDefault(fsp);
var require$$0__default = /*#__PURE__*/_interopDefault(require$$0);

const availableExtensions = new Set([
    'js',
    'cjs',
    'mjs',
    'jsx',
    'ts',
    'tsx',
    'cts',
    'mts'
]);
const suffixedExportConventions = new Set([
    'react-server',
    'react-native',
    'edge-light',
    'development',
    'production'
]);
const SRC = 'src';
const DIST = 'dist';
const dtsExtensionsMap = {
    js: 'd.ts',
    cjs: 'd.cts',
    mjs: 'd.mts'
};
const tsExtensions = new Set([
    'ts',
    'tsx',
    'cts',
    'mts'
]);
const DEFAULT_TS_CONFIG = {
    compilerOptions: {
        module: 'ESNext',
        moduleResolution: 'bundler'
    }
};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var picocolors = {exports: {}};

let tty = require$$0__default.default;
let isColorSupported = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.argv.includes("--color") || process.platform === "win32" || tty.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env);
let formatter = (open, close, replace = open)=>(input)=>{
        let string = "" + input;
        let index = string.indexOf(close, open.length);
        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
let replaceClose = (string, close, replace, index)=>{
    let start = string.substring(0, index) + replace;
    let end = string.substring(index + close.length);
    let nextIndex = end.indexOf(close);
    return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
};
let createColors = (enabled = isColorSupported)=>({
        isColorSupported: enabled,
        reset: enabled ? (s)=>`\x1b[0m${s}\x1b[0m` : String,
        bold: enabled ? formatter("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m") : String,
        dim: enabled ? formatter("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m") : String,
        italic: enabled ? formatter("\x1b[3m", "\x1b[23m") : String,
        underline: enabled ? formatter("\x1b[4m", "\x1b[24m") : String,
        inverse: enabled ? formatter("\x1b[7m", "\x1b[27m") : String,
        hidden: enabled ? formatter("\x1b[8m", "\x1b[28m") : String,
        strikethrough: enabled ? formatter("\x1b[9m", "\x1b[29m") : String,
        black: enabled ? formatter("\x1b[30m", "\x1b[39m") : String,
        red: enabled ? formatter("\x1b[31m", "\x1b[39m") : String,
        green: enabled ? formatter("\x1b[32m", "\x1b[39m") : String,
        yellow: enabled ? formatter("\x1b[33m", "\x1b[39m") : String,
        blue: enabled ? formatter("\x1b[34m", "\x1b[39m") : String,
        magenta: enabled ? formatter("\x1b[35m", "\x1b[39m") : String,
        cyan: enabled ? formatter("\x1b[36m", "\x1b[39m") : String,
        white: enabled ? formatter("\x1b[37m", "\x1b[39m") : String,
        gray: enabled ? formatter("\x1b[90m", "\x1b[39m") : String,
        bgBlack: enabled ? formatter("\x1b[40m", "\x1b[49m") : String,
        bgRed: enabled ? formatter("\x1b[41m", "\x1b[49m") : String,
        bgGreen: enabled ? formatter("\x1b[42m", "\x1b[49m") : String,
        bgYellow: enabled ? formatter("\x1b[43m", "\x1b[49m") : String,
        bgBlue: enabled ? formatter("\x1b[44m", "\x1b[49m") : String,
        bgMagenta: enabled ? formatter("\x1b[45m", "\x1b[49m") : String,
        bgCyan: enabled ? formatter("\x1b[46m", "\x1b[49m") : String,
        bgWhite: enabled ? formatter("\x1b[47m", "\x1b[49m") : String
    });
picocolors.exports = createColors();
picocolors.exports.createColors = createColors;

var picocolorsExports = picocolors.exports;
var pc = /*@__PURE__*/getDefaultExportFromCjs(picocolorsExports);

const defaultColorFn = (text)=>text;
function color(prefixColor) {
    return pc.isColorSupported ? pc[prefixColor] : defaultColorFn;
}
const logger = {
    log (...arg) {
        console.log(...arg);
    },
    warn (...arg) {
        console.warn(color('yellow')('⚠️'), ...arg);
    },
    error (...arg) {
        console.error(color('red')('⨯'), ...arg);
    },
    info (...arg) {
        console.log(color('green')('✓'), ...arg);
    }
};
function paint(prefix, prefixColor, ...arg) {
    if (pc.isColorSupported) {
        console.log(pc[prefixColor](prefix), ...arg);
    } else {
        console.log(prefix, ...arg);
    }
}

function exit(err) {
    logger.error(err);
    process.exit(1);
}
function hasPackageJson(cwd) {
    return fileExists(path__default.default.resolve(cwd, 'package.json'));
}
async function getPackageMeta(cwd) {
    const pkgFilePath = path__default.default.resolve(cwd, 'package.json');
    let targetPackageJson = {};
    try {
        targetPackageJson = JSON.parse(await fsp__default.default.readFile(pkgFilePath, {
            encoding: 'utf-8'
        }));
    } catch (_) {}
    return targetPackageJson;
}
function isTypescriptFile(filename) {
    const ext = path__default.default.extname(filename).slice(1);
    return tsExtensions.has(ext);
}
function fileExists(filePath) {
    return fs__default.default.existsSync(filePath);
}
const hasAvailableExtension = (filename)=>availableExtensions.has(path__default.default.extname(filename).slice(1));
const hasCjsExtension = (filename)=>path__default.default.extname(filename) === '.cjs';
// TODO: add unit test
const baseNameWithoutExtension = (filename)=>path__default.default.basename(filename, path__default.default.extname(filename));
const isTestFile = (filename)=>/\.(test|spec)$/.test(baseNameWithoutExtension(filename));

function getPackageTypings(pkg) {
    return pkg.types || pkg.typings;
}
// Reached the end of the export path
function isExportLike(field) {
    if (typeof field === 'string') return true;
    return Object.entries(field).every(// Every value is string and key is not start with '.'
    ([key, value])=>typeof value === 'string' && !key.startsWith('.'));
}
function constructFullExportCondition(exportCondition, packageType) {
    let fullExportCond;
    if (typeof exportCondition === 'string') {
        const exportType = getExportTypeFromFile(exportCondition, packageType);
        fullExportCond = {
            [exportType]: exportCondition
        };
    } else {
        const exportTypes = Object.keys(exportCondition);
        fullExportCond = {};
        exportTypes.forEach((exportType)=>{
            const condition = exportCondition[exportType];
            // Filter out nullable value
            if (condition) {
                fullExportCond[exportType] = condition;
            }
        });
    }
    return fullExportCond;
}
function joinRelativePath(...segments) {
    let result = path.join(...segments);
    // If the first segment starts with '.', ensure the result does too.
    if (segments[0] === '.' && !result.startsWith('.')) {
        result = './' + result;
    }
    return result;
}
const getFirstExportPath = (fullExportCondition)=>{
    // Handle all export cond { <require|import|default>: ... }
    if (typeof fullExportCondition === 'object') {
        for (const key of Object.keys(fullExportCondition)){
            if (key.startsWith('.') || key === 'types') {
                continue;
            }
            return fullExportCondition[key];
        }
    }
    return fullExportCondition;
};
const joinExportAndCondition = (exportPath, condition)=>{
    return (exportPath === '.' ? '' : exportPath) + '.' + condition;
};
function findExport(exportPath, exportCondition, paths, packageType, currentPath) {
    // Skip `types` field, it cannot be the entry point
    if (exportPath === 'types') return;
    if (isExportLike(exportCondition)) {
        const fullExportCondition = constructFullExportCondition(exportCondition, packageType);
        if (exportPath.startsWith('.')) {
            paths[exportPath] = {
                ...paths[exportPath],
                ...fullExportCondition
            };
        } else {
            const exportJsBundlePath = getFirstExportPath(fullExportCondition);
            if (suffixedExportConventions.has(exportPath)) {
                const specialPath = joinExportAndCondition(currentPath, exportPath);
                paths[specialPath] = {
                    ...paths[specialPath],
                    ...exportCondition
                };
            } else {
                // exportPath is exportType, import, require, ...
                // merge to currentPath
                paths[currentPath] = {
                    ...paths[currentPath],
                    [exportPath]: exportJsBundlePath
                };
            }
        }
        return;
    }
    Object.keys(exportCondition).forEach((subpath)=>{
        if (subpath.startsWith('.')) {
            // subpath is actual export path, ./a, ./b, ...
            const nestedExportPath = joinRelativePath(currentPath, subpath);
            const nestedExportCondition = exportCondition[subpath];
            findExport(nestedExportPath, nestedExportCondition, paths, packageType, nestedExportPath);
        } else {
            // subpath is exportType, import, require, ...
            const exportType = subpath;
            if (typeof exportCondition[subpath] === 'object') {
                const defaultPath = exportCondition[subpath].default;
                if (defaultPath) {
                    const nestedExportCondition = {
                        [exportType]: defaultPath
                    };
                    findExport(exportPath, nestedExportCondition, paths, packageType, currentPath);
                }
                // Find special export type, such as import: { development: './dev.js', production: './prod.js' }
                const conditionSpecialTypes = Object.keys(exportCondition[exportType]).filter((key)=>suffixedExportConventions.has(key));
                if (conditionSpecialTypes.length > 0) {
                    for (const conditionSpecialType of conditionSpecialTypes){
                        const nestedExportConditionPath = {
                            [exportType]: exportCondition[exportType][conditionSpecialType]
                        };
                        findExport(conditionSpecialType, nestedExportConditionPath, paths, packageType, currentPath);
                    }
                }
            }
            const defaultPath = typeof exportCondition[subpath] === 'object' ? exportCondition[subpath].default : exportCondition[subpath];
            const nestedExportCondition = {
                [exportType]: defaultPath
            };
            findExport(exportPath, nestedExportCondition, paths, packageType, currentPath);
        }
    });
}
/**
 *
 * Convert package.exports field to paths mapping
 * Example
 *
 * Input:
 * {
 *   "./sub": {
 *     "import": {
 *       "types": "./sub.js",
 *       "default": "./sub.cjs",
 *     }
 *   }
 * }
 *
 * Output:
 * {
 *   "./sub": {
 *     "import": "./sub.js",
 *     "require": "./sub.cjs",
 *     "types": "./sub.d.ts",
 *   }
 * }
 *
 */ function parseExport(exportsCondition, packageType) {
    const paths = {};
    const initialPath = '.';
    if (typeof exportsCondition === 'string') {
        paths[initialPath] = constructFullExportCondition(exportsCondition, packageType);
    } else if (typeof exportsCondition === 'object') {
        if (isExportLike(exportsCondition)) {
            paths[initialPath] = constructFullExportCondition(exportsCondition, packageType);
        } else {
            Object.keys(exportsCondition).forEach((key)=>{
                const exportCondition = exportsCondition[key];
                findExport(key, exportCondition, paths, packageType, initialPath);
            });
        }
    }
    return paths;
}
/**
 * Get package exports paths
 *
 * Example:
 *
 * ```json
 * {
 *  "exports": {
 *    ".": {
 *      "require": "./dist/index.cjs",
 *      "module": "./dist/index.esm.js",
 *      "default": "./dist/index.esm.js"
 *    },
 *    "./foo": {
 *      "require": "./dist/foo.cjs",
 *      "module": "./dist/foo.esm.js",
 *      "default": "./dist/foo.esm.js"
 *   }
 * }
 *
 * ```
 *
 * will be parsed to:
 *
 * ```js
 * {
 *   '.': {
 *     main: './dist/index.cjs',
 *     module: './dist/index.esm.js',
 *     export: './dist/index.esm.js'
 *   },
 *   './foo': {
 *     main: './dist/foo.cjs',
 *     module: './dist/foo.esm.js',
 *     export: './dist/foo.esm.js'
 *   }
 *
 *
 * pkg.main and pkg.module will be added to ['.'] if exists
 */ function getExportPaths(pkg, resolvedWildcardExports) {
    var _pathsMap_;
    let pathsMap = {};
    const packageType = getPackageType(pkg);
    const isEsmPackage = isESModulePackage(packageType);
    const exportsConditions = resolvedWildcardExports != null ? resolvedWildcardExports : pkg.exports;
    if (exportsConditions) {
        const paths = parseExport(exportsConditions, packageType);
        pathsMap = {
            ...pathsMap,
            ...paths
        };
    }
    // main export '.' from main/module/typings
    let mainExportCondition;
    if (pkg.main) {
        const mainExportType = isEsmPackage ? hasCjsExtension(pkg.main) ? 'require' : 'import' : 'require';
        mainExportCondition = {
            [mainExportType]: pkg.main
        };
    }
    const defaultMainExport = constructFullExportCondition({
        ...mainExportCondition,
        module: pkg.module,
        types: getPackageTypings(pkg)
    }, packageType);
    if (!isEsmPackage && ((_pathsMap_ = pathsMap['.']) == null ? void 0 : _pathsMap_['require'])) {
        // pathsMap's exports.require are prioritized.
        defaultMainExport['require'] = pathsMap['.']['require'];
    }
    // Merge the main export into '.' paths
    const mainExport = {
        ...pathsMap['.'],
        ...defaultMainExport
    };
    // main export is not empty
    if (Object.keys(mainExport).length > 0) {
        pathsMap['.'] = {
            ...pathsMap['.'],
            ...mainExport
        };
    }
    return pathsMap;
}
function getPackageType(pkg) {
    return pkg.type || 'commonjs';
}
function isESModulePackage(packageType) {
    return packageType === 'module';
}
function getExportTypeFromFile(filename, pkgType) {
    const isESModule = isESModulePackage(pkgType);
    const isCjsExt = filename.endsWith('.cjs');
    const isEsmExt = filename.endsWith('.mjs');
    const exportType = isEsmExt ? 'import' : isCjsExt ? 'require' : isESModule ? 'import' : 'require';
    return exportType;
}

function lint$1(pkg) {
    const { name, main, exports } = pkg;
    const isESM = isESModulePackage(pkg.type);
    const exportPaths = getExportPaths(pkg);
    if (!name) {
        logger.warn('Missing package name');
    }
    const state = {
        badMainExtension: false,
        badMainExport: false,
        invalidExportsFieldType: false,
        badCjsRequireExport: {
            value: false,
            paths: []
        },
        badCjsImportExport: {
            value: false,
            paths: []
        },
        badEsmRequireExport: {
            value: false,
            paths: []
        },
        badEsmImportExport: {
            value: false,
            paths: []
        }
    };
    // Validate ESM package
    if (isESM) {
        if (exports) {
            if (typeof exports === 'string') {
                if (hasCjsExtension(exports)) {
                    state.badMainExport = true;
                }
            }
            if (typeof exports !== 'object') {
                state.invalidExportsFieldType = true;
            } else {
                Object.keys(exportPaths).forEach((key)=>{
                    const exportConditions = exportPaths[key];
                    if (typeof exportConditions === 'object') {
                        var // @ts-ignore TODO: fix the type
                        _exportConditions_require, // @ts-ignore TODO: fix the type
                        _exportConditions_import;
                        var _exportConditions_require_default;
                        const requirePath = (_exportConditions_require_default = (_exportConditions_require = exportConditions.require) == null ? void 0 : _exportConditions_require.default) != null ? _exportConditions_require_default : exportConditions.require;
                        var _exportConditions_import_default;
                        const importPath = (_exportConditions_import_default = (_exportConditions_import = exportConditions.import) == null ? void 0 : _exportConditions_import.default) != null ? _exportConditions_import_default : exportConditions.import;
                        const requireExt = requirePath && path__default.default.extname(requirePath);
                        const importExt = importPath && path__default.default.extname(importPath);
                        if (requireExt === '.mjs' || requireExt === '.js') {
                            state.badEsmRequireExport.value = true;
                            state.badEsmRequireExport.paths.push(requirePath);
                        }
                        if (importExt === '.cjs') {
                            state.badEsmImportExport.value = true;
                            state.badEsmImportExport.paths.push(importPath);
                        }
                    }
                });
            }
        }
    } else {
        // Validate CJS package
        if (main && path__default.default.extname(main) === '.mjs') {
            state.badMainExtension = true;
        }
        if (exports) {
            if (typeof exports === 'string') {
                if (path__default.default.extname(exports) === '.mjs') {
                    state.badMainExport = true;
                }
            }
            if (typeof exports !== 'object') {
                state.invalidExportsFieldType = true;
            } else {
                Object.keys(exportPaths).forEach((key)=>{
                    const exportConditions = exportPaths[key];
                    if (typeof exportConditions === 'object') {
                        var // @ts-ignore TODO: fix the type
                        _exportConditions_require, // @ts-ignore TODO: fix the type
                        _exportConditions_import;
                        var _exportConditions_require_default;
                        const requirePath = (_exportConditions_require_default = (_exportConditions_require = exportConditions.require) == null ? void 0 : _exportConditions_require.default) != null ? _exportConditions_require_default : exportConditions.require;
                        var _exportConditions_import_default;
                        const importPath = (_exportConditions_import_default = (_exportConditions_import = exportConditions.import) == null ? void 0 : _exportConditions_import.default) != null ? _exportConditions_import_default : exportConditions.import;
                        const requireExt = requirePath && path__default.default.extname(requirePath);
                        const importExt = importPath && path__default.default.extname(importPath);
                        if (requireExt === '.mjs') {
                            state.badCjsRequireExport.value = true;
                            state.badCjsRequireExport.paths.push(requirePath);
                        }
                        if (importExt === '.js' || importExt === '.cjs') {
                            state.badCjsImportExport.value = true;
                            state.badCjsImportExport.paths.push(importPath);
                        }
                    }
                });
            }
        }
    }
    if (state.badMainExtension) {
        logger.warn('Cannot export `main` field with .mjs extension in CJS package, only .js extension is allowed');
    }
    if (state.badMainExport) {
        if (isESM) {
            logger.warn('Cannot export `exports` field with .cjs extension in ESM package, only .mjs and .js extensions are allowed');
        } else {
            logger.warn('Cannot export `exports` field with .mjs extension in CJS package, only .js and .cjs extensions are allowed');
        }
    }
    if (state.invalidExportsFieldType) {
        logger.warn('Invalid exports field type, only object or string is allowed');
    }
    if (state.badCjsRequireExport.value) {
        logger.warn('Cannot export `require` field with .mjs extension in CJS package, only .cjs and .js extensions are allowed');
        state.badCjsRequireExport.paths.forEach((p)=>{
            logger.warn(`  ${p}`);
        });
    }
    if (state.badCjsImportExport.value) {
        logger.warn('Cannot export `import` field with .js or .cjs extension in CJS package, only .mjs extensions are allowed');
        state.badCjsImportExport.paths.forEach((p)=>{
            logger.warn(`  ${p}`);
        });
    }
    if (state.badEsmRequireExport.value) {
        logger.warn('Cannot export `require` field with .js or .mjs extension in ESM package, only .cjs extensions are allowed');
        state.badEsmRequireExport.paths.forEach((p)=>{
            logger.warn(`  ${p}`);
        });
    }
    if (state.badEsmImportExport.value) {
        logger.warn('Cannot export `import` field with .cjs extension in ESM package, only .js and .mjs extensions are allowed');
        state.badEsmImportExport.paths.forEach((p)=>{
            logger.warn(`  ${p}`);
        });
    }
}

var version = "4.4.8";

function relativify(path) {
    return path.startsWith('.') ? path : `./${path}`;
}

async function writeDefaultTsconfig(tsConfigPath) {
    await fs.promises.writeFile(tsConfigPath, JSON.stringify(DEFAULT_TS_CONFIG, null, 2), 'utf-8');
    logger.log(`Detected using TypeScript but tsconfig.json is missing, created a ${pc.blue('tsconfig.json')} for you.`);
}

// Output with posix style in package.json
function getDistPath(...subPaths) {
    return `./${DIST}/${subPaths.join('/')}`;
}
const normalizeBaseNameToExportName = (baseName)=>{
    return /^index(\.|$)/.test(baseName) ? '.' : relativify(baseName);
};
function createExportCondition(exportName, sourceFile, moduleType) {
    const isTsSourceFile = isTypescriptFile(sourceFile);
    let cjsExtension = 'js';
    let esmExtension = 'mjs';
    if (moduleType === 'module') {
        cjsExtension = 'cjs';
        esmExtension = 'js';
    }
    if (isTsSourceFile) {
        return {
            import: {
                types: getDistPath('es', `${exportName}.${dtsExtensionsMap[esmExtension]}`),
                default: getDistPath('es', `${exportName}.${esmExtension}`)
            },
            require: {
                types: getDistPath('cjs', `${exportName}.${dtsExtensionsMap[cjsExtension]}`),
                default: getDistPath('cjs', `${exportName}.${cjsExtension}`)
            }
        };
    }
    return {
        import: getDistPath(`${exportName}.mjs`),
        require: getDistPath(`${exportName}.${cjsExtension}`)
    };
}
async function collectSourceEntries(sourceFolderPath) {
    const bins = new Map();
    const exportsEntries = new Map();
    const entryFileDirentList = await fsp__default.default.readdir(sourceFolderPath, {
        withFileTypes: true
    });
    for (const dirent of entryFileDirentList){
        if (dirent.isDirectory()) {
            if (dirent.name === 'bin') {
                const binDirentList = await fsp__default.default.readdir(path__default.default.join(sourceFolderPath, dirent.name), {
                    withFileTypes: true
                });
                for (const binDirent of binDirentList){
                    if (binDirent.isFile()) {
                        const binFileAbsolutePath = path__default.default.join(sourceFolderPath, dirent.name, binDirent.name);
                        const binName = baseNameWithoutExtension(binDirent.name);
                        if (fs__default.default.existsSync(binFileAbsolutePath)) {
                            bins.set(binName, binDirent.name);
                        }
                    }
                }
            } else {
                // Search folder/<index>.<ext> convention entries
                for (const extension of availableExtensions){
                    const indexFile = path__default.default.join(dirent.name, `index.${extension}`);
                    if (fs__default.default.existsSync(indexFile) && !isTestFile(indexFile)) {
                        exportsEntries.set(dirent.name, indexFile);
                        break;
                    }
                }
            }
        } else if (dirent.isFile()) {
            const isAvailableExtension = availableExtensions.has(path__default.default.extname(dirent.name).slice(1));
            if (isAvailableExtension) {
                const baseName = baseNameWithoutExtension(dirent.name);
                const isBinFile = baseName === 'bin';
                if (isBinFile) {
                    bins.set('.', dirent.name);
                } else {
                    if (hasAvailableExtension(dirent.name) && !isTestFile(dirent.name)) {
                        exportsEntries.set(baseName, dirent.name);
                    }
                }
            }
        }
    }
    return {
        bins,
        exportsEntries
    };
}
function createExportConditionPair(exportName, sourceFile, moduleType) {
    // <exportName>.<specialCondition>
    let specialCondition;
    let exportCondName;
    if (exportName.indexOf('.') > 0) {
        const [originExportName, specialConditionName] = exportName.split('.');
        specialCondition = {
            [specialConditionName]: getDistPath('es', `${originExportName}-${specialConditionName}.mjs`)
        };
        exportCondName = normalizeBaseNameToExportName(originExportName);
        return [
            exportCondName,
            specialCondition
        ];
    }
    exportCondName = normalizeBaseNameToExportName(exportName);
    const exportCond = createExportCondition(exportName, sourceFile, moduleType);
    return [
        exportCondName,
        exportCond
    ];
}
async function prepare(cwd) {
    const sourceFolder = path__default.default.resolve(cwd, SRC);
    if (!fs__default.default.existsSync(sourceFolder)) {
        logger.error(`Source folder ${sourceFolder} does not exist. Cannot proceed to configure \`exports\` field.`);
        process.exit(1);
    }
    let hasPackageJson = false;
    const pkgJsonPath = path__default.default.join(cwd, 'package.json');
    let pkgJson = {};
    if (fs__default.default.existsSync(pkgJsonPath)) {
        hasPackageJson = true;
        const pkgJsonString = await fsp__default.default.readFile(pkgJsonPath, 'utf-8');
        pkgJson = JSON.parse(pkgJsonString);
    }
    // configure `files` field with `dist`
    const files = pkgJson.files || [];
    if (!files.includes(DIST)) {
        files.push(DIST);
    }
    pkgJson.files = files;
    let isUsingTs = false;
    // Collect bins and exports entries
    const { bins, exportsEntries } = await collectSourceEntries(sourceFolder);
    const tsConfigPath = path__default.default.join(cwd, 'tsconfig.json');
    const sourceFiles = [
        ...exportsEntries.values()
    ].concat([
        ...bins.values()
    ]);
    const hasTypeScriptFiles = sourceFiles.some((filename)=>isTypescriptFile(filename));
    if (hasTypeScriptFiles) {
        isUsingTs = true;
        if (!fs__default.default.existsSync(tsConfigPath)) {
            await writeDefaultTsconfig(tsConfigPath);
        }
    }
    // Configure as ESM package by default if there's no package.json
    if (!hasPackageJson) {
        pkgJson.type = 'module';
    }
    if (bins.size > 0) {
        logger.log('Discovered binaries entries:');
        const maxLengthOfBinName = Math.max(...Array.from(bins.keys()).map((binName)=>normalizeBaseNameToExportName(binName).length));
        for (const [binName, binFile] of bins.entries()){
            const spaces = ' '.repeat(Math.max(maxLengthOfBinName - normalizeBaseNameToExportName(binName).length, 0));
            logger.log(`  ${normalizeBaseNameToExportName(binName)}${spaces}: ${binFile}`);
        }
        if (bins.size === 1 && bins.has('.')) {
            pkgJson.bin = getDistPath('bin', 'index.js');
        } else {
            pkgJson.bin = {};
            for (const [binName] of bins.entries()){
                pkgJson.bin[binName === '.' ? pkgJson.name : binName] = getDistPath('bin', binName + '.js');
            }
        }
    }
    if (exportsEntries.size > 0) {
        logger.log('Discovered exports entries:');
        const maxLengthOfExportName = Math.max(...Array.from(exportsEntries.keys()).map((exportName)=>normalizeBaseNameToExportName(exportName).length));
        for (const [exportName, exportFile] of exportsEntries.entries()){
            const spaces = ' '.repeat(Math.max(maxLengthOfExportName - normalizeBaseNameToExportName(exportName).length, 0));
            logger.log(`  ${normalizeBaseNameToExportName(exportName)}${spaces}: ${exportFile}`);
        }
        const pkgExports = {};
        for (const [exportName, sourceFile] of exportsEntries.entries()){
            const [key, value] = createExportConditionPair(exportName, sourceFile, pkgJson.type);
            pkgExports[key] = {
                ...value,
                ...pkgExports[key]
            };
        }
        // Configure node10 module resolution
        if (exportsEntries.has('index')) {
            const isESM = pkgJson.type === 'module';
            const mainExport = pkgExports['.'];
            const mainCondition = isESM ? 'import' : 'require';
            pkgJson.main = isUsingTs ? mainExport[mainCondition].default : mainExport[mainCondition];
            pkgJson.module = isUsingTs ? mainExport.import.default : mainExport.import;
            if (isUsingTs) {
                pkgJson.types = mainExport[mainCondition].types;
            }
        }
        // Assign the properties by order: files, main, module, types, exports
        if (Object.keys(pkgExports).length > 0) {
            if (!pkgJson.exports) {
                pkgJson.exports = pkgExports;
            } else {
                // Update existing exports
                Object.keys(pkgExports).forEach((exportName)=>{
                    if (pkgJson.exports[exportName]) {
                        pkgJson.exports[exportName] = pkgExports[exportName];
                    }
                });
            }
        }
    }
    await fsp__default.default.writeFile(pkgJsonPath, JSON.stringify(pkgJson, null, 2));
    logger.info('Configured `exports` in package.json');
}

const helpMessage = `
Usage: bunchee [options]

Options:
  -v, --version          output the version number
  -w, --watch            watch src files changes
  -m, --minify           compress output. default: false
  -o, --output <file>    specify output filename
  -f, --format <format>  type of output (esm, amd, cjs, iife, umd, system), default: esm
  -h, --help             output usage information
  --prepare              auto configure package.json exports for building
  --external <mod>       specify an external dependency, separate by comma
  --no-external          do not bundle external dependencies
  --no-clean             do not clean dist folder before building, default: false
  --target <target>      js features target: swc target es versions. default: es2015
  --runtime <runtime>    build runtime (nodejs, browser). default: browser
  --env <env>            inlined process env variables, separate by comma. default: NODE_ENV
  --cwd <cwd>            specify current working directory
  --sourcemap            enable sourcemap generation, default: false
  --dts                  determine if need to generate types, default: false
`;
function help() {
    logger.log(helpMessage);
}
async function lint(cwd) {
    // Not package.json detected, skip package linting
    if (!await hasPackageJson(cwd)) {
        return;
    }
    await lint$1(await getPackageMeta(cwd));
}
function parseCliArgs(argv) {
    let args;
    args = arg__default.default({
        '--cwd': String,
        '--dts': Boolean,
        '--output': String,
        '--format': String,
        '--watch': Boolean,
        '--minify': Boolean,
        '--help': Boolean,
        '--version': Boolean,
        '--runtime': String,
        '--target': String,
        '--sourcemap': Boolean,
        '--env': String,
        '--external': String,
        '--no-external': Boolean,
        '--no-clean': Boolean,
        '--prepare': Boolean,
        '-h': '--help',
        '-v': '--version',
        '-w': '--watch',
        '-o': '--output',
        '-f': '--format',
        '-m': '--minify'
    }, {
        permissive: true,
        argv
    });
    const source = args._[0];
    const parsedArgs = {
        source,
        format: args['--format'],
        file: args['--output'],
        watch: args['--watch'],
        minify: args['--minify'],
        sourcemap: !!args['--sourcemap'],
        cwd: args['--cwd'],
        dts: args['--dts'],
        help: args['--help'],
        version: args['--version'],
        runtime: args['--runtime'],
        target: args['--target'],
        external: !!args['--no-external'] ? null : args['--external'],
        clean: !args['--no-clean'],
        env: args['--env'],
        prepare: !!args['--prepare']
    };
    return parsedArgs;
}
async function run(args) {
    var _args_external;
    const { source, format, watch, minify, sourcemap, target, runtime, dts, env, clean } = args;
    const cwd = args.cwd || process.cwd();
    const file = args.file ? path__default.default.resolve(cwd, args.file) : undefined;
    const bundleConfig = {
        dts,
        file,
        format,
        cwd,
        target,
        runtime,
        external: args.external === null ? null : ((_args_external = args.external) == null ? void 0 : _args_external.split(',')) || [],
        watch: !!watch,
        minify: !!minify,
        sourcemap: sourcemap === false ? false : true,
        env: (env == null ? void 0 : env.split(',')) || [],
        clean
    };
    if (args.version) {
        return logger.log(version);
    }
    if (args.help) {
        return help();
    }
    if (args.prepare) {
        return await prepare(cwd);
    }
    const cliEntry = source ? path__default.default.resolve(cwd, source) : '';
    // lint package
    await lint(cwd);
    try {
        await bunchee.bundle(cliEntry, bundleConfig);
    } catch (err) {
        if (err.name === 'NOT_EXISTED') {
            help();
            return exit(err);
        }
        throw err;
    }
    // watching mode
    if (watch) {
        logger.log(`Watching project ${cwd}...`);
        return;
    }
    // build mode
    logger.log();
    paint('✓', 'green', `bunchee ${version} build completed`);
}
async function main() {
    let params, error;
    try {
        params = parseCliArgs(process.argv.slice(2));
    } catch (err) {
        error = err;
    }
    if (error || !params) {
        if (!error) help();
        return exit(error);
    }
    await run(params);
}
main().catch(exit);
