Object.defineProperty(exports, '__esModule', { value: true });

var rollup = require('rollup');
var fsp = require('fs/promises');
var fs = require('fs');
var path = require('path');
var perf_hooks = require('perf_hooks');
var module$1 = require('module');
var require$$0 = require('tty');
var rimraf = require('rimraf');
var pluginWasm = require('@rollup/plugin-wasm');
var rollupPluginSwc3 = require('rollup-plugin-swc3');
var commonjs = require('@rollup/plugin-commonjs');
var json = require('@rollup/plugin-json');
var pluginNodeResolve = require('@rollup/plugin-node-resolve');
var replace = require('@rollup/plugin-replace');
var preserveDirectives = require('rollup-preserve-directives');
var MagicString = require('magic-string');
var CleanCSS = require('clean-css');
var pluginutils = require('@rollup/pluginutils');
var prettyBytes = require('pretty-bytes');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var fsp__default = /*#__PURE__*/_interopDefault(fsp);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var path__default = /*#__PURE__*/_interopDefault(path);
var require$$0__default = /*#__PURE__*/_interopDefault(require$$0);
var commonjs__default = /*#__PURE__*/_interopDefault(commonjs);
var json__default = /*#__PURE__*/_interopDefault(json);
var replace__default = /*#__PURE__*/_interopDefault(replace);
var preserveDirectives__default = /*#__PURE__*/_interopDefault(preserveDirectives);
var MagicString__default = /*#__PURE__*/_interopDefault(MagicString);
var CleanCSS__default = /*#__PURE__*/_interopDefault(CleanCSS);
var prettyBytes__default = /*#__PURE__*/_interopDefault(prettyBytes);

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var picocolors = {exports: {}};

let tty = require$$0__default.default;
let isColorSupported = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.argv.includes("--color") || process.platform === "win32" || tty.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env);
let formatter = (open, close, replace = open)=>(input)=>{
        let string = "" + input;
        let index = string.indexOf(close, open.length);
        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
    };
let replaceClose = (string, close, replace, index)=>{
    let start = string.substring(0, index) + replace;
    let end = string.substring(index + close.length);
    let nextIndex = end.indexOf(close);
    return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
};
let createColors = (enabled = isColorSupported)=>({
        isColorSupported: enabled,
        reset: enabled ? (s)=>`\x1b[0m${s}\x1b[0m` : String,
        bold: enabled ? formatter("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m") : String,
        dim: enabled ? formatter("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m") : String,
        italic: enabled ? formatter("\x1b[3m", "\x1b[23m") : String,
        underline: enabled ? formatter("\x1b[4m", "\x1b[24m") : String,
        inverse: enabled ? formatter("\x1b[7m", "\x1b[27m") : String,
        hidden: enabled ? formatter("\x1b[8m", "\x1b[28m") : String,
        strikethrough: enabled ? formatter("\x1b[9m", "\x1b[29m") : String,
        black: enabled ? formatter("\x1b[30m", "\x1b[39m") : String,
        red: enabled ? formatter("\x1b[31m", "\x1b[39m") : String,
        green: enabled ? formatter("\x1b[32m", "\x1b[39m") : String,
        yellow: enabled ? formatter("\x1b[33m", "\x1b[39m") : String,
        blue: enabled ? formatter("\x1b[34m", "\x1b[39m") : String,
        magenta: enabled ? formatter("\x1b[35m", "\x1b[39m") : String,
        cyan: enabled ? formatter("\x1b[36m", "\x1b[39m") : String,
        white: enabled ? formatter("\x1b[37m", "\x1b[39m") : String,
        gray: enabled ? formatter("\x1b[90m", "\x1b[39m") : String,
        bgBlack: enabled ? formatter("\x1b[40m", "\x1b[49m") : String,
        bgRed: enabled ? formatter("\x1b[41m", "\x1b[49m") : String,
        bgGreen: enabled ? formatter("\x1b[42m", "\x1b[49m") : String,
        bgYellow: enabled ? formatter("\x1b[43m", "\x1b[49m") : String,
        bgBlue: enabled ? formatter("\x1b[44m", "\x1b[49m") : String,
        bgMagenta: enabled ? formatter("\x1b[45m", "\x1b[49m") : String,
        bgCyan: enabled ? formatter("\x1b[46m", "\x1b[49m") : String,
        bgWhite: enabled ? formatter("\x1b[47m", "\x1b[49m") : String
    });
picocolors.exports = createColors();
picocolors.exports.createColors = createColors;

var picocolorsExports = picocolors.exports;
var pc = /*@__PURE__*/getDefaultExportFromCjs(picocolorsExports);

const availableExtensions = new Set([
    'js',
    'cjs',
    'mjs',
    'jsx',
    'ts',
    'tsx',
    'cts',
    'mts'
]);
const nodeResolveExtensions = [
    '.mjs',
    '.cjs',
    '.js',
    '.json',
    '.node',
    '.jsx'
];
const suffixedExportConventions = new Set([
    'react-server',
    'react-native',
    'edge-light',
    'development',
    'production'
]);
const availableESExtensionsRegex = /\.(m|c)?[jt]sx?$/;
const SRC = 'src';
const dtsExtensionsMap = {
    js: 'd.ts',
    cjs: 'd.cts',
    mjs: 'd.mts'
};
const disabledWarnings = new Set([
    'MIXED_EXPORTS',
    'PREFER_NAMED_EXPORTS',
    'UNRESOLVED_IMPORT',
    'THIS_IS_UNDEFINED',
    'INVALID_ANNOTATION',
    'UNUSED_EXTERNAL_IMPORT'
]);
const tsExtensions = new Set([
    'ts',
    'tsx',
    'cts',
    'mts'
]);
const DEFAULT_TS_CONFIG = {
    compilerOptions: {
        module: 'ESNext',
        moduleResolution: 'bundler'
    }
};

const defaultColorFn = (text)=>text;
function color(prefixColor) {
    return pc.isColorSupported ? pc[prefixColor] : defaultColorFn;
}
const logger = {
    log (...arg) {
        console.log(...arg);
    },
    warn (...arg) {
        console.warn(color('yellow')('⚠️'), ...arg);
    },
    error (...arg) {
        console.error(color('red')('⨯'), ...arg);
    },
    info (...arg) {
        console.log(color('green')('✓'), ...arg);
    }
};

function exit(err) {
    logger.error(err);
    process.exit(1);
}
async function getPackageMeta(cwd) {
    const pkgFilePath = path__default.default.resolve(cwd, 'package.json');
    let targetPackageJson = {};
    try {
        targetPackageJson = JSON.parse(await fsp__default.default.readFile(pkgFilePath, {
            encoding: 'utf-8'
        }));
    } catch (_) {}
    return targetPackageJson;
}
function isTypescriptFile(filename) {
    const ext = path__default.default.extname(filename).slice(1);
    return tsExtensions.has(ext);
}
function fileExists(filePath) {
    return fs__default.default.existsSync(filePath);
}
async function removeDir(dirPath) {
    try {
        const dirStat = await fsp__default.default.stat(dirPath);
        if (dirStat.isDirectory()) {
            await rimraf.rimraf(dirPath);
        }
    } catch (err) {
        if (err.code !== 'ENOENT') {
            throw err;
        }
    }
}
const isNotNull = (n)=>Boolean(n);
function resolveSourceFile(cwd, filename) {
    return path__default.default.resolve(cwd, SRC, filename);
}
function findSourceEntryFile(cwd, exportPath, exportTypeSuffix, ext) {
    const filename = resolveSourceFile(cwd, `${exportPath}${exportTypeSuffix ? `.${exportTypeSuffix}` : ''}.${ext}`);
    if (fileExists(filename)) {
        return filename;
    }
    const subFolderIndexFilename = resolveSourceFile(cwd, `${exportPath}/index${exportTypeSuffix ? `.${exportTypeSuffix}` : ''}.${ext}`);
    try {
        if (fileExists(subFolderIndexFilename)) {
            return subFolderIndexFilename;
        }
    } catch  {}
    return undefined;
}
// Map '.' -> './index.[ext]'
// Map './lite' -> './lite.[ext]'
// Return undefined if no match or if it's package.json exports
async function getSourcePathFromExportPath(cwd, exportPath, exportType) {
    for (const ext of availableExtensions){
        // ignore package.json
        if (exportPath === '/package.json') return;
        if (exportPath === '.') exportPath = './index';
        // Find convention-based source file for specific export types
        // $binary represents `pkg.bin`
        if (suffixedExportConventions.has(exportType) && exportType !== '$binary') {
            const filename = await findSourceEntryFile(cwd, exportPath, exportType, ext);
            if (filename) return filename;
        }
        const filename = await findSourceEntryFile(cwd, exportPath, null, ext);
        if (filename) return filename;
    }
    return;
}
// TODO: add unit test
// Unlike path.basename, forcedly removing extension
function filePathWithoutExtension(filePath) {
    if (!filePath) return;
    const lastDotIndex = filePath.lastIndexOf('.');
    const lastSlashIndex = filePath.lastIndexOf('/');
    if (lastDotIndex !== -1 && lastDotIndex > lastSlashIndex) {
        return filePath.slice(0, filePath.indexOf('.', lastSlashIndex + 1));
    }
    return filePath;
}
const nonNullable = (n)=>Boolean(n);
const hasAvailableExtension = (filename)=>availableExtensions.has(path__default.default.extname(filename).slice(1));
const hasCjsExtension = (filename)=>path__default.default.extname(filename) === '.cjs';
// TODO: add unit test
const baseNameWithoutExtension = (filename)=>path__default.default.basename(filename, path__default.default.extname(filename));
const memoize = (fn, resolver)=>{
    const cache = new Map();
    return (...args)=>{
        const key = resolver ? resolver(...args) : JSON.stringify({
            args
        });
        const existing = cache.get(key);
        if (existing !== undefined) {
            return existing;
        }
        const result = fn(...args);
        cache.set(key, result);
        return result;
    };
};

let hasLoggedTsWarning = false;
function resolveTypescriptHandler(cwd) {
    let ts;
    const m = new module$1.Module('', undefined);
    m.paths = module$1.Module._nodeModulePaths(cwd);
    try {
        ts = m.require('typescript');
    } catch (e) {
        console.error(e);
        if (!hasLoggedTsWarning) {
            hasLoggedTsWarning = true;
            exit('Could not load TypeScript compiler. Try to install `typescript` as dev dependency');
        }
    }
    return ts;
}
const resolveTypescript = memoize(resolveTypescriptHandler);
function resolveTsConfigHandler(cwd) {
    let tsCompilerOptions = {};
    let tsConfigPath;
    tsConfigPath = path.resolve(cwd, 'tsconfig.json');
    if (fileExists(tsConfigPath)) {
        const ts = resolveTypescript(cwd);
        const basePath = tsConfigPath ? path.dirname(tsConfigPath) : cwd;
        const tsconfigJSON = ts.readConfigFile(tsConfigPath, ts.sys.readFile).config;
        tsCompilerOptions = ts.parseJsonConfigFileContent(tsconfigJSON, ts.sys, basePath).options;
    } else {
        return null;
    }
    return {
        tsCompilerOptions,
        tsConfigPath
    };
}
const resolveTsConfig = memoize(resolveTsConfigHandler);
async function convertCompilerOptions(cwd, json) {
    const ts = resolveTypescript(cwd);
    return ts.convertCompilerOptionsFromJson(json, './');
}
async function writeDefaultTsconfig(tsConfigPath) {
    await fs.promises.writeFile(tsConfigPath, JSON.stringify(DEFAULT_TS_CONFIG, null, 2), 'utf-8');
    logger.log(`Detected using TypeScript but tsconfig.json is missing, created a ${pc.blue('tsconfig.json')} for you.`);
}

const FILENAME_REGEX = /__filename/;
const DIRNAME_REGEX = /__dirname/;
const GLOBAL_REQUIRE_REGEX = /require(\.resolve)?\(/;
const PolyfillComment = '/** rollup-private-do-not-use-esm-shim-polyfill */';
const createESMShim = ({ filename, dirname, globalRequire })=>{
    const useNodeUrl = filename || dirname;
    const useNodePath = dirname;
    const useNodeModule = globalRequire;
    return `\
${PolyfillComment}
${useNodeUrl ? `import __node_cjsUrl from 'node:url'` : ''};
${useNodePath ? `import __node_cjsPath from 'node:path';` : ''}
${useNodeModule ? `import __node_cjsModule from 'node:module';` : ''}
${useNodeUrl ? 'const __filename = __node_cjsUrl.fileURLToPath(import.meta.url);' : ''}
${useNodePath ? 'const __dirname = __node_cjsPath.dirname(__filename);' : ''}
${useNodeModule ? 'const require = __node_cjsModule.createRequire(import.meta.url);' : ''}
`.trim() + '\n';
};
function esmShim() {
    return {
        name: 'esm-shim',
        transform: {
            order: 'post',
            handler (code, id) {
                const ext = path.extname(id);
                if (!availableESExtensionsRegex.test(ext) || code.includes(PolyfillComment)) {
                    return null;
                }
                let hasFilename = false;
                let hasDirname = false;
                let hasGlobalRequire = false;
                if (FILENAME_REGEX.test(code)) {
                    hasFilename = true;
                }
                if (DIRNAME_REGEX.test(code)) {
                    hasDirname = true;
                }
                if (GLOBAL_REQUIRE_REGEX.test(code)) {
                    hasGlobalRequire = true;
                }
                if (!hasFilename && !hasDirname && !hasGlobalRequire) {
                    return null;
                }
                const magicString = new MagicString__default.default(code);
                let ast = null;
                try {
                    // rollup 2 built-in parser doesn't have `allowShebang`, we need to use the sliced code here. Hence the `magicString.toString()`
                    ast = this.parse(magicString.toString(), {
                        allowReturnOutsideFunction: true
                    });
                } catch (e) {
                    console.warn(e);
                    return null;
                }
                if (ast.type !== 'Program') {
                    return null;
                }
                let lastImportNode = null;
                for (const node of ast.body){
                    if (node.type === 'ImportDeclaration') {
                        lastImportNode = node;
                        continue;
                    }
                }
                let end = 0;
                if (lastImportNode) {
                    end = lastImportNode.end;
                } else {
                    end = ast.body.length > 0 ? ast.body[0].end : 0;
                }
                magicString.appendRight(end, '\n' + createESMShim({
                    filename: hasFilename,
                    dirname: hasDirname,
                    globalRequire: hasGlobalRequire
                }));
                return {
                    code: magicString.toString(),
                    map: magicString.generateMap({
                        hires: true
                    })
                };
            }
        }
    };
}

const helpers = {
    cssImport: {
        // have to assign r.type = 'text/css' to make it work in Safari
        global: `\
function __insertCSS(code) {
  if (!code || typeof document == 'undefined') return
  let head = document.head || document.getElementsByTagName('head')[0]
  let style = document.createElement('style')
  style.type = 'text/css'
  head.appendChild(style)
  ;style.styleSheet ? (style.styleSheet.cssText = code) : style.appendChild(document.createTextNode(code))
}
`,
        create (code) {
            return `__insertCSS(${JSON.stringify(code)});`;
        }
    },
    cssAssertionImport: {
        global: '',
        create (code) {
            return `\
const sheet = new CSSStyleSheet()
sheet.replaceSync(${JSON.stringify(code)})
export default sheet`;
        }
    }
};
const cleanCssInstance = new CleanCSS__default.default({});
function minify(code) {
    return cleanCssInstance.minify(code).styles;
}
function inlineCss(options) {
    const cssIds = new Set();
    var _options_exclude;
    const filter = pluginutils.createFilter([
        '**/*.css'
    ], (_options_exclude = options.exclude) != null ? _options_exclude : []);
    // Follow up for rollup 4 for better support of assertion support https://github.com/rollup/rollup/issues/4818
    return {
        name: 'inline-css',
        transform (code, id) {
            if (!filter(id)) return;
            if (options.skip) return '';
            const cssCode = minify(code);
            cssIds.add(id);
            return {
                code: helpers.cssImport.create(cssCode),
                map: {
                    mappings: ''
                }
            };
        },
        renderChunk (code) {
            const dependenciesIds = this.getModuleIds();
            let foundCss = false;
            for (const depId of dependenciesIds){
                if (depId && cssIds.has(depId)) {
                    foundCss = true;
                    break;
                }
            }
            if (!foundCss) return;
            return {
                code: `${helpers.cssImport.global}\n${code}`,
                map: {
                    mappings: ''
                }
            };
        }
    };
}

function rawContent({ exclude }) {
    const filter = pluginutils.createFilter([
        '**/*.data',
        '**/*.txt'
    ], exclude);
    return {
        name: 'string',
        transform (code, id) {
            if (filter(id)) {
                return {
                    code: `const data = ${JSON.stringify(code)};\nexport default data;`,
                    map: null
                };
            }
            return null;
        }
    };
}

function relativify(path) {
    return path.startsWith('.') ? path : `./${path}`;
}

// Alias entries to import path
// e.g.
// For a resolved file, if it's one of the entries,
// aliases it as export path, such as <absolute file> -> <pkg>/<export path>
function aliasEntries({ entry, entries, entriesAlias, format, dts }) {
    let currentDistPath = '';
    const entryAliasWithoutSelf = {
        ...entriesAlias,
        [entry]: null
    };
    const pathToRelativeDistMap = new Map();
    for (const [, exportCondition] of Object.entries(entries)){
        var _Object_entries_find;
        const { import: importCond, require: requireCond, default: defaultCond } = exportCondition.export;
        const firstCond = (_Object_entries_find = Object.entries(exportCondition.export).find(([key, cond])=>key !== 'types' && cond != null)) == null ? void 0 : _Object_entries_find[1];
        if (dts) {
            const fallbackCond = defaultCond || firstCond;
            // For cjs, use require() instead of import
            const firstDistPath = (format === 'cjs' ? requireCond : importCond) || fallbackCond;
            if (firstDistPath) {
                if (entry !== exportCondition.source) {
                    pathToRelativeDistMap.set(exportCondition.source, firstDistPath);
                } else {
                    currentDistPath = firstDistPath;
                }
            }
        }
    }
    return {
        name: 'alias',
        resolveId: {
            async handler (source, importer, options) {
                const resolvedId = await this.resolve(source, importer, options);
                if (resolvedId != null) {
                    if (dts) {
                        // For types, generate relative path to the other type files,
                        // this will be compatible for the node10 ts module resolution.
                        const aliasedId = pathToRelativeDistMap.get(resolvedId.id);
                        if (aliasedId != null && aliasedId !== currentDistPath) {
                            const ext = path__default.default.extname(aliasedId);
                            const filePathBase = filePathWithoutExtension(path__default.default.relative(path__default.default.dirname(currentDistPath), aliasedId));
                            const relativePath = relativify(filePathBase + ext);
                            return {
                                id: relativePath,
                                external: true
                            };
                        }
                    } else {
                        const aliasedId = entryAliasWithoutSelf[resolvedId.id];
                        if (aliasedId != null) {
                            return {
                                id: aliasedId
                            };
                        }
                    }
                }
                return null;
            }
        }
    };
}

function prependDirectives() {
    return {
        name: 'prependDirective',
        transform: {
            order: 'post',
            handler (code, id) {
                var _moduleInfo_meta;
                const moduleInfo = this.getModuleInfo(id);
                if (moduleInfo == null ? void 0 : (_moduleInfo_meta = moduleInfo.meta) == null ? void 0 : _moduleInfo_meta.preserveDirectives) {
                    const firstDirective = moduleInfo.meta.preserveDirectives.directives[0];
                    if (firstDirective) {
                        const directive = firstDirective.value;
                        const directiveCode = `'${directive}';`;
                        return directiveCode + '\n' + code;
                    }
                }
                return null;
            }
        }
    };
}

function getPackageTypings(pkg) {
    return pkg.types || pkg.typings;
}
// Reached the end of the export path
function isExportLike(field) {
    if (typeof field === 'string') return true;
    return Object.entries(field).every(// Every value is string and key is not start with '.'
    ([key, value])=>typeof value === 'string' && !key.startsWith('.'));
}
function constructFullExportCondition(exportCondition, packageType) {
    let fullExportCond;
    if (typeof exportCondition === 'string') {
        const exportType = getExportTypeFromFile(exportCondition, packageType);
        fullExportCond = {
            [exportType]: exportCondition
        };
    } else {
        const exportTypes = Object.keys(exportCondition);
        fullExportCond = {};
        exportTypes.forEach((exportType)=>{
            const condition = exportCondition[exportType];
            // Filter out nullable value
            if (condition) {
                fullExportCond[exportType] = condition;
            }
        });
    }
    return fullExportCond;
}
function joinRelativePath(...segments) {
    let result = path.join(...segments);
    // If the first segment starts with '.', ensure the result does too.
    if (segments[0] === '.' && !result.startsWith('.')) {
        result = './' + result;
    }
    return result;
}
const getFirstExportPath = (fullExportCondition)=>{
    // Handle all export cond { <require|import|default>: ... }
    if (typeof fullExportCondition === 'object') {
        for (const key of Object.keys(fullExportCondition)){
            if (key.startsWith('.') || key === 'types') {
                continue;
            }
            return fullExportCondition[key];
        }
    }
    return fullExportCondition;
};
const joinExportAndCondition = (exportPath, condition)=>{
    return (exportPath === '.' ? '' : exportPath) + '.' + condition;
};
function findExport(exportPath, exportCondition, paths, packageType, currentPath) {
    // Skip `types` field, it cannot be the entry point
    if (exportPath === 'types') return;
    if (isExportLike(exportCondition)) {
        const fullExportCondition = constructFullExportCondition(exportCondition, packageType);
        if (exportPath.startsWith('.')) {
            paths[exportPath] = {
                ...paths[exportPath],
                ...fullExportCondition
            };
        } else {
            const exportJsBundlePath = getFirstExportPath(fullExportCondition);
            if (suffixedExportConventions.has(exportPath)) {
                const specialPath = joinExportAndCondition(currentPath, exportPath);
                paths[specialPath] = {
                    ...paths[specialPath],
                    ...exportCondition
                };
            } else {
                // exportPath is exportType, import, require, ...
                // merge to currentPath
                paths[currentPath] = {
                    ...paths[currentPath],
                    [exportPath]: exportJsBundlePath
                };
            }
        }
        return;
    }
    Object.keys(exportCondition).forEach((subpath)=>{
        if (subpath.startsWith('.')) {
            // subpath is actual export path, ./a, ./b, ...
            const nestedExportPath = joinRelativePath(currentPath, subpath);
            const nestedExportCondition = exportCondition[subpath];
            findExport(nestedExportPath, nestedExportCondition, paths, packageType, nestedExportPath);
        } else {
            // subpath is exportType, import, require, ...
            const exportType = subpath;
            if (typeof exportCondition[subpath] === 'object') {
                const defaultPath = exportCondition[subpath].default;
                if (defaultPath) {
                    const nestedExportCondition = {
                        [exportType]: defaultPath
                    };
                    findExport(exportPath, nestedExportCondition, paths, packageType, currentPath);
                }
                // Find special export type, such as import: { development: './dev.js', production: './prod.js' }
                const conditionSpecialTypes = Object.keys(exportCondition[exportType]).filter((key)=>suffixedExportConventions.has(key));
                if (conditionSpecialTypes.length > 0) {
                    for (const conditionSpecialType of conditionSpecialTypes){
                        const nestedExportConditionPath = {
                            [exportType]: exportCondition[exportType][conditionSpecialType]
                        };
                        findExport(conditionSpecialType, nestedExportConditionPath, paths, packageType, currentPath);
                    }
                }
            }
            const defaultPath = typeof exportCondition[subpath] === 'object' ? exportCondition[subpath].default : exportCondition[subpath];
            const nestedExportCondition = {
                [exportType]: defaultPath
            };
            findExport(exportPath, nestedExportCondition, paths, packageType, currentPath);
        }
    });
}
/**
 *
 * Convert package.exports field to paths mapping
 * Example
 *
 * Input:
 * {
 *   "./sub": {
 *     "import": {
 *       "types": "./sub.js",
 *       "default": "./sub.cjs",
 *     }
 *   }
 * }
 *
 * Output:
 * {
 *   "./sub": {
 *     "import": "./sub.js",
 *     "require": "./sub.cjs",
 *     "types": "./sub.d.ts",
 *   }
 * }
 *
 */ function parseExport(exportsCondition, packageType) {
    const paths = {};
    const initialPath = '.';
    if (typeof exportsCondition === 'string') {
        paths[initialPath] = constructFullExportCondition(exportsCondition, packageType);
    } else if (typeof exportsCondition === 'object') {
        if (isExportLike(exportsCondition)) {
            paths[initialPath] = constructFullExportCondition(exportsCondition, packageType);
        } else {
            Object.keys(exportsCondition).forEach((key)=>{
                const exportCondition = exportsCondition[key];
                findExport(key, exportCondition, paths, packageType, initialPath);
            });
        }
    }
    return paths;
}
/**
 * Get package exports paths
 *
 * Example:
 *
 * ```json
 * {
 *  "exports": {
 *    ".": {
 *      "require": "./dist/index.cjs",
 *      "module": "./dist/index.esm.js",
 *      "default": "./dist/index.esm.js"
 *    },
 *    "./foo": {
 *      "require": "./dist/foo.cjs",
 *      "module": "./dist/foo.esm.js",
 *      "default": "./dist/foo.esm.js"
 *   }
 * }
 *
 * ```
 *
 * will be parsed to:
 *
 * ```js
 * {
 *   '.': {
 *     main: './dist/index.cjs',
 *     module: './dist/index.esm.js',
 *     export: './dist/index.esm.js'
 *   },
 *   './foo': {
 *     main: './dist/foo.cjs',
 *     module: './dist/foo.esm.js',
 *     export: './dist/foo.esm.js'
 *   }
 *
 *
 * pkg.main and pkg.module will be added to ['.'] if exists
 */ function getExportPaths(pkg, resolvedWildcardExports) {
    var _pathsMap_;
    let pathsMap = {};
    const packageType = getPackageType(pkg);
    const isEsmPackage = isESModulePackage(packageType);
    const exportsConditions = resolvedWildcardExports != null ? resolvedWildcardExports : pkg.exports;
    if (exportsConditions) {
        const paths = parseExport(exportsConditions, packageType);
        pathsMap = {
            ...pathsMap,
            ...paths
        };
    }
    // main export '.' from main/module/typings
    let mainExportCondition;
    if (pkg.main) {
        const mainExportType = isEsmPackage ? hasCjsExtension(pkg.main) ? 'require' : 'import' : 'require';
        mainExportCondition = {
            [mainExportType]: pkg.main
        };
    }
    const defaultMainExport = constructFullExportCondition({
        ...mainExportCondition,
        module: pkg.module,
        types: getPackageTypings(pkg)
    }, packageType);
    if (!isEsmPackage && ((_pathsMap_ = pathsMap['.']) == null ? void 0 : _pathsMap_['require'])) {
        // pathsMap's exports.require are prioritized.
        defaultMainExport['require'] = pathsMap['.']['require'];
    }
    // Merge the main export into '.' paths
    const mainExport = {
        ...pathsMap['.'],
        ...defaultMainExport
    };
    // main export is not empty
    if (Object.keys(mainExport).length > 0) {
        pathsMap['.'] = {
            ...pathsMap['.'],
            ...mainExport
        };
    }
    return pathsMap;
}
function getPackageType(pkg) {
    return pkg.type || 'commonjs';
}
function isESModulePackage(packageType) {
    return packageType === 'module';
}
function constructDefaultExportCondition(value, packageType) {
    const isEsmPackage = isESModulePackage(packageType);
    let exportCondition;
    if (typeof value === 'string') {
        const types = getPackageTypings(value);
        exportCondition = {
            [isEsmPackage ? 'import' : 'require']: value,
            ...types && {
                types
            }
        };
    } else {
        exportCondition = value;
    }
    return constructFullExportCondition(exportCondition, packageType);
}
function isEsmExportName(name, ext) {
    return [
        'import',
        'module'
    ].includes(name) || ext === 'mjs';
}
function isCjsExportName(pkg, exportCondition, ext) {
    const isESModule = isESModulePackage(pkg.type);
    const isCjsCondition = [
        'require',
        'main'
    ].includes(exportCondition);
    const isNotEsmExportName = !isEsmExportName(exportCondition, ext);
    return !isESModule && isNotEsmExportName && (ext !== 'mjs' || isCjsCondition) || ext === 'cjs';
}
function getExportsDistFilesOfCondition(pkg, parsedExportCondition, cwd) {
    const dist = [];
    const exportConditionNames = Object.keys(parsedExportCondition.export);
    const uniqueFiles = new Set();
    for (const exportCondition of exportConditionNames){
        if (exportCondition === 'types') {
            continue;
        }
        const filePath = parsedExportCondition.export[exportCondition];
        const ext = path.extname(filePath).slice(1);
        const relativePath = parsedExportCondition.export[exportCondition];
        const distFile = path.resolve(cwd, relativePath);
        const format = isCjsExportName(pkg, exportCondition, ext) ? 'cjs' : 'esm';
        if (uniqueFiles.has(distFile)) {
            continue;
        }
        uniqueFiles.add(distFile);
        dist.push({
            format,
            file: distFile
        });
    }
    return dist;
}
function getExportFileTypePath(absoluteJsBundlePath) {
    const dirName = path.dirname(absoluteJsBundlePath);
    const baseName = baseNameWithoutExtension(absoluteJsBundlePath);
    const ext = path.extname(absoluteJsBundlePath).slice(1);
    const typeExtension = dtsExtensionsMap[ext];
    return path.join(dirName, baseName + '.' + typeExtension);
}
function getExportTypeFromFile(filename, pkgType) {
    const isESModule = isESModulePackage(pkgType);
    const isCjsExt = filename.endsWith('.cjs');
    const isEsmExt = filename.endsWith('.mjs');
    const exportType = isEsmExt ? 'import' : isCjsExt ? 'require' : isESModule ? 'import' : 'require';
    return exportType;
}

const swcMinifyOptions = {
    compress: true,
    format: {
        comments: 'some'
    },
    mangle: {
        toplevel: true
    }
};
// return { 'process.env.<key>': '<value>' }
function getDefinedInlineVariables(envs, parsedExportCondition) {
    if (!envs.includes('NODE_ENV')) {
        envs.push('NODE_ENV');
    }
    const envVars = envs.reduce((acc, key)=>{
        const value = process.env[key];
        if (typeof value !== 'undefined') {
            acc['process.env.' + key] = JSON.stringify(value);
        }
        return acc;
    }, {});
    // handle .development, .production
    const condName = parsedExportCondition.name.startsWith('.') ? parsedExportCondition.name.slice(1) : parsedExportCondition.name;
    const exportConditionNames = new Set(Object.keys(parsedExportCondition.export).concat(condName));
    // For development and production convention, we override the NODE_ENV value
    if (exportConditionNames.has('development')) {
        envVars['process.env.NODE_ENV'] = JSON.stringify('development');
    } else if (exportConditionNames.has('production')) {
        envVars['process.env.NODE_ENV'] = JSON.stringify('production');
    }
    if (exportConditionNames.has('edge-light')) {
        envVars['EdgeRuntime'] = JSON.stringify('edge-runtime');
    }
    return envVars;
}
/**
 * return {
 *   <absolute source path>: <pkg>/<export>
 * }
 */ function getReversedAlias(entries) {
    const alias = {};
    for (const [entryImportPath, exportCondition] of Object.entries(entries)){
        const exportType = entryImportPath.split('.')[1] // e.g. index.react-server, pick react-server
        ;
        if (!exportType) {
            alias[exportCondition.source] = entryImportPath;
        }
    }
    return alias;
}
async function buildInputConfig(entry, bundleConfig, exportCondition, buildContext, dts) {
    var _bundleConfig_file, _bundleConfig_file1;
    const { entries, pkg, cwd, tsOptions: { tsConfigPath, tsCompilerOptions }, pluginContext } = buildContext;
    const hasNoExternal = bundleConfig.external === null;
    var _bundleConfig_external;
    const externals = hasNoExternal ? [] : [
        pkg.peerDependencies,
        pkg.dependencies,
        pkg.peerDependenciesMeta
    ].filter((n)=>Boolean(n)).map((o)=>Object.keys(o)).reduce((a, b)=>a.concat(b), []).concat((_bundleConfig_external = bundleConfig.external) != null ? _bundleConfig_external : []);
    for (const [exportImportPath, exportCondition] of Object.entries(entries)){
        const entryFilePath = exportCondition.source;
        if (entryFilePath !== entry) {
            externals.push(exportImportPath);
            externals.push(entryFilePath);
        }
    }
    const inlineDefinedValues = getDefinedInlineVariables(bundleConfig.env || [], exportCondition);
    const { useTypeScript } = buildContext;
    const { runtime, target: jscTarget, minify: shouldMinify } = bundleConfig;
    const hasSpecifiedTsTarget = Boolean(tsCompilerOptions.target && tsConfigPath);
    const swcParserConfig = {
        syntax: useTypeScript ? 'typescript' : 'ecmascript',
        [useTypeScript ? 'tsx' : 'jsx']: true,
        exportDefaultFrom: true
    };
    const swcOptions = {
        jsc: {
            ...!hasSpecifiedTsTarget && {
                target: jscTarget
            },
            loose: true,
            externalHelpers: false,
            parser: swcParserConfig,
            ...shouldMinify && {
                minify: {
                    ...swcMinifyOptions,
                    sourceMap: bundleConfig.sourcemap
                }
            }
        },
        sourceMaps: bundleConfig.sourcemap,
        inlineSourcesContent: false,
        isModule: true
    };
    const sizePlugin = pluginContext.outputState.plugin(cwd);
    // common plugins for both dts and ts assets that need to be processed
    // If it's a .d.ts file under non-ESM package or .d.cts file, use cjs types alias.
    const aliasFormat = dts ? ((_bundleConfig_file = bundleConfig.file) == null ? void 0 : _bundleConfig_file.endsWith('.d.cts')) || ((_bundleConfig_file1 = bundleConfig.file) == null ? void 0 : _bundleConfig_file1.endsWith('.d.ts')) && !isESModulePackage(pkg.type) ? 'cjs' : 'esm' : bundleConfig.format;
    const commonPlugins = [
        json__default.default(),
        sizePlugin,
        aliasEntries({
            entry,
            entries,
            entriesAlias: pluginContext.entriesAlias,
            format: aliasFormat,
            dts
        })
    ];
    const typesPlugins = [
        ...commonPlugins,
        inlineCss({
            skip: true
        })
    ];
    if (useTypeScript) {
        const enableIncrementalWithoutBuildInfo = tsCompilerOptions.incremental && !tsCompilerOptions.tsBuildInfoFile;
        const incrementalOptions = enableIncrementalWithoutBuildInfo ? {
            incremental: false
        } : undefined;
        const compositeOptions = tsCompilerOptions.composite ? {
            composite: false
        } : undefined;
        const { options: overrideResolvedTsOptions } = await convertCompilerOptions(cwd, {
            declaration: true,
            noEmit: false,
            noEmitOnError: true,
            emitDeclarationOnly: true,
            checkJs: false,
            declarationMap: false,
            skipLibCheck: true,
            // preserveSymlinks should always be set to false to avoid issues with
            // resolving types from <reference> from node_modules
            preserveSymlinks: false,
            target: 'ESNext',
            ...!tsCompilerOptions.jsx ? {
                jsx: 'react-jsx'
            } : undefined,
            // error TS5074: Option '--incremental' can only be specified using tsconfig, emitting to single
            // file or when option '--tsBuildInfoFile' is specified.
            ...incrementalOptions,
            // error TS6379: Composite projects may not disable incremental compilation.
            ...compositeOptions
        });
        const dtsPlugin = require('rollup-plugin-dts').default({
            tsconfig: tsConfigPath,
            compilerOptions: overrideResolvedTsOptions
        });
        typesPlugins.push(dtsPlugin);
    }
    const plugins = (dts ? typesPlugins : [
        ...commonPlugins,
        inlineCss({
            exclude: /node_modules/
        }),
        rawContent({
            exclude: /node_modules/
        }),
        preserveDirectives__default.default(),
        prependDirectives(),
        replace__default.default({
            values: inlineDefinedValues,
            preventAssignment: true
        }),
        pluginNodeResolve.nodeResolve({
            preferBuiltins: runtime === 'node',
            extensions: nodeResolveExtensions
        }),
        bundleConfig.format === 'esm' && esmShim(),
        pluginWasm.wasm(),
        rollupPluginSwc3.swc({
            include: availableESExtensionsRegex,
            exclude: 'node_modules',
            // Use `false` to disable retrieving tsconfig.json
            tsconfig: tsConfigPath != null ? tsConfigPath : false,
            ...swcOptions
        }),
        commonjs__default.default({
            exclude: bundleConfig.external || null
        })
    ]).filter(isNotNull);
    return {
        input: entry,
        external (id) {
            return externals.some((name)=>id === name || id.startsWith(name + '/'));
        },
        plugins,
        treeshake: {
            propertyReadSideEffects: false
        },
        onwarn (warning, warn) {
            const code = warning.code || '';
            // Some may not have types, like CLI binary
            if (dts && code === 'EMPTY_BUNDLE') return;
            if (disabledWarnings.has(code)) return;
            // If the circular dependency warning is from node_modules, ignore it
            if (code === 'CIRCULAR_DEPENDENCY' && /Circular dependency: node_modules/.test(warning.message)) {
                return;
            }
            warn(warning);
        }
    };
}
function hasEsmExport(exportPaths, tsCompilerOptions) {
    let hasEsm = false;
    for(const key in exportPaths){
        const exportInfo = exportPaths[key];
        const exportInfoEntries = Object.entries(exportInfo);
        if (exportInfoEntries.some(([exportType, file])=>isEsmExportName(exportType, file))) {
            hasEsm = true;
            break;
        }
    }
    return Boolean(hasEsm || (tsCompilerOptions == null ? void 0 : tsCompilerOptions.esModuleInterop));
}
function getModuleLater(moduleMeta) {
    const directives = (moduleMeta.preserveDirectives || {
        directives: []
    }).directives.map((d)=>d.replace(/^use /, '')).filter((d)=>d !== 'strict');
    const moduleLayer = directives[0];
    return moduleLayer;
}
// dependencyGraphMap: Map<subModuleId, Set<entryParentId>>
function createSplitChunks(dependencyGraphMap, entryFiles) {
    // If there's existing chunk being splitted, and contains a layer { <id>: <chunkGroup> }
    const splitChunksGroupMap = new Map();
    return function splitChunks(id, ctx) {
        const moduleInfo = ctx.getModuleInfo(id);
        if (!moduleInfo) {
            return;
        }
        const { isEntry } = moduleInfo;
        const moduleMeta = moduleInfo.meta;
        const moduleLayer = getModuleLater(moduleMeta);
        // Collect the sub modules of the entry, if they're having layer, and the same layer with the entry, push them to the dependencyGraphMap.
        if (isEntry) {
            const subModuleIds = ctx.getModuleIds();
            for (const subId of subModuleIds){
                const subModuleInfo = ctx.getModuleInfo(subId);
                if (!subModuleInfo) {
                    continue;
                }
                const subModuleLayer = getModuleLater(moduleMeta);
                if (subModuleLayer === moduleLayer) {
                    if (!dependencyGraphMap.has(subId)) {
                        dependencyGraphMap.set(subId, new Set());
                    }
                    dependencyGraphMap.get(subId).add([
                        id,
                        moduleLayer
                    ]);
                }
            }
        }
        // If current module has a layer, and it's not an entry
        if (moduleLayer && !isEntry) {
            // If the module is imported by the entry:
            // when the module layer is same as entry layer, keep it as part of entry and don't split it;
            // when the module layer is different from entry layer, split the module into a separate chunk as a separate boundary.
            if (dependencyGraphMap.has(id)) {
                const parentModuleIds = Array.from(dependencyGraphMap.get(id));
                const isImportFromOtherEntry = parentModuleIds.some(([id])=>{
                    // If other entry is dependency of this entry
                    if (entryFiles.has(id)) {
                        const entryModuleInfo = ctx.getModuleInfo(id);
                        const entryModuleLayer = getModuleLater(entryModuleInfo ? entryModuleInfo.meta : {});
                        return entryModuleLayer === moduleLayer;
                    }
                    return false;
                });
                if (isImportFromOtherEntry) return;
                const isPartOfCurrentEntry = parentModuleIds.every(([, layer])=>layer === moduleLayer);
                if (isPartOfCurrentEntry) {
                    if (splitChunksGroupMap.has(id)) {
                        return splitChunksGroupMap.get(id);
                    }
                    return;
                }
                const chunkName = path__default.default.basename(id, path__default.default.extname(id));
                const chunkGroup = `${chunkName}-${moduleLayer}`;
                splitChunksGroupMap.set(id, chunkGroup);
                return chunkGroup;
            }
        }
        return;
    };
}
async function buildOutputConfigs(entry, bundleConfig, exportCondition, buildContext, dts) {
    const { format } = bundleConfig;
    const { entries, pkg, exportPaths, cwd, tsOptions: { tsCompilerOptions }, pluginContext } = buildContext;
    // Add esm mark and interop helper if esm export is detected
    const useEsModuleMark = hasEsmExport(exportPaths, tsCompilerOptions);
    const absoluteOutputFile = path.resolve(cwd, bundleConfig.file);
    const outputFileExtension = path.extname(absoluteOutputFile);
    const name = filePathWithoutExtension(absoluteOutputFile);
    var _exportCondition_export_types;
    const dtsFile = path.resolve(cwd, dts ? bundleConfig.file : (_exportCondition_export_types = exportCondition.export.types) != null ? _exportCondition_export_types : getExportFileTypePath(bundleConfig.file));
    const typesDir = path.dirname(dtsFile);
    const jsDir = path.dirname(absoluteOutputFile);
    const outputFile = dts ? dtsFile : absoluteOutputFile;
    const entryFiles = new Set(Object.values(entries).map((entry)=>entry.source));
    const inputOptions = await buildInputConfig(entry, bundleConfig, exportCondition, buildContext, dts);
    const outputOptions = {
        name: pkg.name || name,
        dir: dts ? typesDir : jsDir,
        format,
        exports: 'named',
        esModule: useEsModuleMark || 'if-default-prop',
        interop: 'auto',
        freeze: false,
        strict: false,
        sourcemap: bundleConfig.sourcemap,
        manualChunks: createSplitChunks(pluginContext.moduleDirectiveLayerMap, entryFiles),
        chunkFileNames () {
            const ext = format === 'cjs' && outputFileExtension === '.cjs' ? 'cjs' : 'js';
            return '[name]-[hash].' + ext;
        },
        // By default in rollup, when creating multiple chunks, transitive imports of entry chunks
        // will be added as empty imports to the entry chunks. Disable to avoid imports hoist outside of boundaries
        hoistTransitiveImports: false,
        entryFileNames: path.basename(outputFile)
    };
    return {
        input: inputOptions,
        output: outputOptions
    };
}
async function buildEntryConfig(bundleConfig, pluginContext, dts) {
    const configs = [];
    const { entries } = pluginContext;
    for (const exportCondition of Object.values(entries)){
        const rollupConfigs = await buildConfig(bundleConfig, exportCondition, pluginContext, dts);
        configs.push(...rollupConfigs);
    }
    return configs;
}
async function collectEntry(// export type, e.g. react-server, edge-light those special cases required suffix
exportType, options) {
    const { cwd, pkg, entries, entryPath, exportCondRef, entryExport: originEntryExport } = options;
    let entryExport = originEntryExport;
    let exportCondForType = {
        ...exportCondRef
    };
    // Special cases of export type, only pass down the exportPaths for the type
    if (suffixedExportConventions.has(exportType)) {
        exportCondForType = {
            [exportType]: exportCondRef[exportType]
        };
    } else if (exportType[0] === '.' && suffixedExportConventions.has(exportType.slice(1))) {
        // e.g. .development, .production that has both esm and cjs export
        exportCondForType = exportCondRef;
        exportType = exportType.slice(1);
        entryExport = entryExport.replace(exportType, '');
    } else {
        // Basic export type, pass down the exportPaths with erasing the special ones
        for (const exportType of suffixedExportConventions){
            delete exportCondForType[exportType];
        }
    }
    let source = entryPath;
    if (source) {
        source = resolveSourceFile(cwd, source);
    } else {
        source = await getSourcePathFromExportPath(cwd, entryExport, exportType);
    }
    if (!source) {
        return;
    }
    const exportCondition = {
        source,
        name: originEntryExport,
        export: exportCondForType
    };
    const nameWithExportPath = pkg.name ? path__default.default.join(pkg.name, exportCondition.name) : exportCondition.name;
    const needsDelimiter = !nameWithExportPath.endsWith('.') && exportType;
    const entryImportPath = nameWithExportPath + (needsDelimiter ? '.' : '') + exportType;
    entries[entryImportPath] = exportCondition;
}
/*
 * build configs for each entry from package exports
 *
 * return { <pkg>/<export>: { input: InputOptions, output: OutputOptions[] }
 */ async function collectEntries(pkg, entryPath, exportPaths, cwd) {
    const entries = {};
    const binaryExports = pkg.bin;
    if (binaryExports) {
        // binDistPaths: [ [ 'bin1', './dist/bin1.js'], [ 'bin2', './dist/bin2.js'] ]
        const binPairs = typeof binaryExports === 'string' ? [
            [
                'bin',
                binaryExports
            ]
        ] : Object.keys(binaryExports).map((key)=>[
                path.join('bin', key),
                binaryExports[key]
            ]);
        const binExportPaths = binPairs.reduce((acc, [binName, binDistPath])=>{
            const exportType = getExportTypeFromFile(binDistPath, pkg.type);
            acc[binName] = {
                [exportType]: binDistPath
            };
            return acc;
        }, {});
        for (const [binName] of binPairs){
            const source = await getSourcePathFromExportPath(cwd, binName, '$binary');
            if (!source) {
                logger.warn(`Cannot find source file for ${binName}`);
                continue;
            }
            const binEntryPath = await resolveSourceFile(cwd, source);
            entries[binName] = {
                source: binEntryPath,
                name: binName,
                export: binExportPaths[binName]
            };
        }
    }
    const collectEntriesPromises = Object.keys(exportPaths).map(async (entryExport)=>{
        const exportCond = exportPaths[entryExport];
        const collectEntryOptions = {
            cwd,
            pkg,
            entries,
            entryPath,
            exportCondRef: exportCond,
            entryExport
        };
        if (entryExport.startsWith('.')) {
            await collectEntry('', collectEntryOptions);
            for (const exportCondType of suffixedExportConventions){
                if (exportCond[exportCondType]) {
                    await collectEntry(exportCondType, collectEntryOptions);
                } else if (entryExport === '.' + exportCondType) {
                    await collectEntry(entryExport, collectEntryOptions);
                }
            }
        }
    });
    await Promise.all(collectEntriesPromises);
    return entries;
}
async function buildConfig(bundleConfig, exportCondition, pluginContext, dts) {
    const { file } = bundleConfig;
    const { pkg, cwd } = pluginContext;
    const entry = exportCondition.source;
    const outputExports = getExportsDistFilesOfCondition(pkg, exportCondition, cwd);
    // If there's nothing found, give a default output
    if (outputExports.length === 0 && !pkg.bin) {
        const defaultFormat = isESModulePackage(pkg.type) ? 'esm' : 'cjs';
        outputExports.push({
            format: defaultFormat,
            file: path.join(cwd, 'dist/index.js')
        });
    }
    let bundleOptions = [];
    // multi outputs with specified format
    // CLI output option is always prioritized
    if (file) {
        var _outputExports_;
        const fallbackFormat = (_outputExports_ = outputExports[0]) == null ? void 0 : _outputExports_.format;
        bundleOptions = [
            {
                resolvedFile: path.resolve(cwd, file),
                format: bundleConfig.format || fallbackFormat
            }
        ];
    } else {
        bundleOptions = outputExports.map((exportDist)=>{
            return {
                resolvedFile: path.resolve(cwd, exportDist.file),
                format: exportDist.format
            };
        });
    }
    if (dts) {
        // types could have duplicates, dedupe them
        // e.g. { types, import, .. } use the same `types` condition with all conditions
        const uniqTypes = new Set();
        bundleOptions.forEach((bundleOption)=>{
            if (exportCondition.export.types) {
                uniqTypes.add(path.resolve(cwd, exportCondition.export.types));
            }
            const typeForExtension = getExportFileTypePath(bundleOption.resolvedFile);
            uniqTypes.add(typeForExtension);
        });
        bundleOptions = Array.from(uniqTypes).map((typeFile)=>{
            return {
                resolvedFile: typeFile,
                format: 'esm'
            };
        });
    }
    const outputConfigs = bundleOptions.map(async (bundleOption)=>{
        return await buildOutputConfigs(entry, {
            ...bundleConfig,
            file: bundleOption.resolvedFile,
            format: bundleOption.format
        }, exportCondition, pluginContext, dts);
    });
    return Promise.all(outputConfigs);
}

// Example: @foo/bar -> bar
const removeScope = (exportPath)=>exportPath.replace(/^@[^/]+\//, '');
function createOutputState({ entries }) {
    const sizeStats = new Map();
    function addSize({ fileName, size, sourceFileName, exportPath }) {
        if (!sizeStats.has(exportPath)) {
            sizeStats.set(exportPath, []);
        }
        const distFilesStats = sizeStats.get(exportPath);
        if (distFilesStats) {
            distFilesStats.push([
                fileName,
                sourceFileName,
                size
            ]);
        }
    }
    const reversedMapping = new Map();
    Object.entries(entries).forEach(([resolvedExportName, entry])=>{
        reversedMapping.set(entry.source, resolvedExportName);
    });
    return {
        plugin: (cwd)=>{
            return {
                name: 'collect-sizes',
                writeBundle (options, bundle) {
                    const dir = options.dir || path__default.default.dirname(options.file);
                    Object.entries(bundle).forEach(([fileName, chunk])=>{
                        const filePath = path__default.default.join(dir, fileName);
                        if (chunk.type !== 'chunk') {
                            return;
                        }
                        const size = chunk.code.length;
                        const sourceFileName = chunk.facadeModuleId || '';
                        const exportPath = removeScope(reversedMapping.get(sourceFileName) || '.');
                        addSize({
                            fileName: path__default.default.isAbsolute(cwd) ? path__default.default.relative(cwd, filePath) : filePath,
                            size,
                            sourceFileName,
                            exportPath
                        });
                    });
                }
            };
        },
        getSizeStats () {
            return sizeStats;
        }
    };
}
function isBin(filename) {
    return filename === 'bin' || filename.startsWith('bin/');
}
function isTypeFile(filename) {
    return filename.endsWith('.d.ts') || filename.endsWith('.d.mts') || filename.endsWith('.d.cts');
}
function normalizeExportName(exportName) {
    const isBinary = isBin(exportName);
    let result = exportName;
    const isSubpathExport = exportName.includes('/');
    const isSpecialExport = exportName.includes('.');
    if (isBinary) {
        result = (exportName.replace(/bin(\/|$)/, '') || '.') + ' (bin)';
    } else if (isSubpathExport || isSpecialExport) {
        const subExportName = exportName.split('/')[1] || exportName;
        if (subExportName.includes('.') && subExportName !== '.') {
            const [originExportName, specialCondition] = subExportName.split('.');
            result = (isSubpathExport ? relativify(originExportName) : '.') + ' (' + specialCondition + ')';
        } else {
            result = isSubpathExport ? relativify(subExportName) : '.';
        }
    } else {
        result = '.';
    }
    return result;
}
function getExportNameWithoutExportCondition(exportName) {
    return exportName.includes('.') ? exportName.split('.')[0] : exportName;
}
function logOutputState(sizeCollector) {
    const stats = sizeCollector.getSizeStats();
    if (stats.size === 0) {
        logger.warn('No build info can be logged');
        return;
    }
    const allFileNameLengths = Array.from(stats.values()).flat(1).map(([filename])=>filename.length);
    const maxFilenameLength = Math.max(...allFileNameLengths);
    const statsArray = [
        ...stats.entries()
    ].sort(([a], [b])=>{
        const comp = getExportNameWithoutExportCondition(a).length - getExportNameWithoutExportCondition(b).length;
        return comp === 0 ? a.localeCompare(b) : comp;
    });
    const maxLengthOfExportName = Math.max(...statsArray.map(([exportName])=>normalizeExportName(exportName).length));
    console.log(pc.underline('Exports'), ' '.repeat(Math.max(maxLengthOfExportName - 'Exports'.length, 0)), pc.underline('File'), ' '.repeat(Math.max(maxFilenameLength - 'File'.length, 0)), pc.underline('Size'));
    statsArray.forEach(([exportName, filesList])=>{
        // sort by file type, first js files then types, js/mjs/cjs are prioritized than .d.ts/.d.mts/.d.cts
        filesList.sort(([a], [b])=>{
            const aIsType = isTypeFile(a);
            const bIsType = isTypeFile(b);
            if (aIsType && bIsType) {
                return 0;
            }
            if (aIsType) {
                return 1;
            }
            if (bIsType) {
                return -1;
            }
            return 0;
        }).forEach((item, index)=>{
            const [filename, , size] = item;
            const normalizedExportName = normalizeExportName(exportName);
            const prefix = index === 0 ? normalizedExportName : ' '.repeat(normalizedExportName.length);
            const filenamePadding = ' '.repeat(Math.max(maxLengthOfExportName, 'Exports'.length) - normalizedExportName.length);
            const isType = isTypeFile(filename);
            const sizePadding = ' '.repeat(Math.max(maxFilenameLength, 'File'.length) - filename.length);
            const prettiedSize = prettyBytes__default.default(size);
            console.log(prefix, filenamePadding, `${pc[isType ? 'dim' : 'bold'](filename)}`, sizePadding, prettiedSize);
        });
    });
}

// TODO: support nested wildcard exportsCondition (e.g. './foo/*')
const getWildcardExports = (exportsCondition)=>{
    return {
        './*': exportsCondition['./*']
    };
};
const isExportable = async (dirent, pathname)=>{
    if (dirent.isDirectory()) {
        const innerDirents = await fsp__default.default.readdir(path__default.default.join(pathname, dirent.name), {
            withFileTypes: true
        });
        return innerDirents.some(({ name })=>name.startsWith('index') && hasAvailableExtension(name));
    }
    return dirent.isFile() && !dirent.name.startsWith('index') && hasAvailableExtension(dirent.name);
};
async function getExportables(cwd, excludeKeys) {
    const pathname = path__default.default.resolve(cwd, SRC);
    const dirents = await fsp__default.default.readdir(pathname, {
        withFileTypes: true
    });
    const exportables = await Promise.all(dirents.map(async (dirent)=>await isExportable(dirent, pathname) && !excludeKeys.includes(dirent.name) ? dirent.name : undefined));
    return exportables.filter(nonNullable);
}
function mapWildcard(wildcardExports, exportables) {
    return exportables.map((exportable)=>{
        const isFile = exportable.includes('.');
        const filename = isFile ? filePathWithoutExtension(exportable) : exportable;
        return {
            [`./${filename}`]: Object.fromEntries(Object.entries(wildcardExports['./*']).map(([key, value])=>[
                    key,
                    value.replace(/\*/g, isFile ? filename : `${filename}/index`)
                ]))
        };
    });
}
async function resolveWildcardExports(exportsCondition, cwd) {
    if (!exportsCondition || typeof exportsCondition === 'string') return undefined;
    const hasWildcard = !!exportsCondition['./*'];
    if (hasWildcard) {
        logger.warn(`The wildcard export "./*" is experimental and may change or be removed at any time.\n` + 'To open an issue, please visit https://github.com/huozhi/bunchee/issues' + '.\n');
        // './foo' -> ['foo']; './foo/bar' -> ['bar']
        // will contain '*' also but it's not a problem
        const excludeKeys = Object.keys(exportsCondition).map((key)=>key.split('/').pop());
        const exportables = await getExportables(cwd, excludeKeys);
        if (exportables.length > 0) {
            const wildcardExports = getWildcardExports(exportsCondition);
            const resolvedWildcardExports = mapWildcard(wildcardExports, exportables);
            const resolvedExports = Object.assign({}, exportsCondition, ...resolvedWildcardExports);
            delete resolvedExports['./*'];
            return resolvedExports;
        }
    }
    return undefined;
}

function assignDefault(options, name, defaultValue) {
    if (!(name in options) || options[name] == null) {
        options[name] = defaultValue;
    }
}
function hasMultiEntryExport(exportPaths) {
    const exportKeys = Object.keys(exportPaths).filter((key)=>key !== './package.json');
    return exportKeys.length > 0 && exportKeys.every((name)=>name.startsWith('.'));
}
async function bundle(cliEntryPath, { cwd: _cwd, ...options } = {}) {
    const cwd = path.resolve(process.cwd(), _cwd || '');
    assignDefault(options, 'format', 'esm');
    assignDefault(options, 'minify', false);
    assignDefault(options, 'target', 'es2015');
    const pkg = await getPackageMeta(cwd);
    const resolvedWildcardExports = await resolveWildcardExports(pkg.exports, cwd);
    const packageType = getPackageType(pkg);
    const exportPaths = getExportPaths(pkg, resolvedWildcardExports);
    const isMultiEntries = hasMultiEntryExport(exportPaths) // exportPathsLength > 1
    ;
    const hasBin = Boolean(pkg.bin);
    const isFromCli = Boolean(cliEntryPath);
    let tsConfig = resolveTsConfig(cwd);
    let hasTsConfig = Boolean(tsConfig == null ? void 0 : tsConfig.tsConfigPath);
    const defaultTsOptions = {
        tsConfigPath: tsConfig == null ? void 0 : tsConfig.tsConfigPath,
        tsCompilerOptions: (tsConfig == null ? void 0 : tsConfig.tsCompilerOptions) || {}
    };
    // Handle single entry file
    if (!isMultiEntries) {
        // Use specified string file path if possible, then fallback to the default behavior entry picking logic
        // e.g. "exports": "./dist/index.js" -> use "./index.<ext>" as entry
        cliEntryPath = cliEntryPath || await getSourcePathFromExportPath(cwd, '.', 'default') || '';
    }
    // Handle CLI input
    if (cliEntryPath) {
        let mainEntryPath;
        let typesEntryPath;
        // with -o option
        if (options.file) {
            mainEntryPath = options.file;
        }
        if (mainEntryPath) {
            if (options.dts) {
                typesEntryPath = getExportFileTypePath(mainEntryPath);
            }
            exportPaths['.'] = constructDefaultExportCondition({
                main: mainEntryPath,
                types: typesEntryPath
            }, packageType);
        }
    }
    const bundleOrWatch = async (rollupConfig)=>{
        if (options.clean) {
            if (!isFromCli) {
                await removeOutputDir(rollupConfig.output, cwd);
            }
        }
        if (options.watch) {
            return runWatch(rollupConfig);
        }
        return runBundle(rollupConfig);
    };
    const hasSpecifiedEntryFile = cliEntryPath ? fs__default.default.existsSync(cliEntryPath) && (await fsp__default.default.stat(cliEntryPath)).isFile() : false;
    const hasNoEntry = !hasSpecifiedEntryFile && !isMultiEntries && !hasBin;
    if (hasNoEntry) {
        if (cliEntryPath) {
            const err = new Error(`Entry file "${cliEntryPath}" does not exist`);
            err.name = 'NOT_EXISTED';
            return Promise.reject(err);
        } else if (cwd) {
            const hasProjectDir = fs__default.default.existsSync(cwd) && (await fsp__default.default.stat(cwd)).isDirectory();
            if (!hasProjectDir) {
                const err = new Error(`Project directory "${cwd}" does not exist`);
                err.name = 'NOT_EXISTED';
                return Promise.reject(err);
            }
        }
    }
    const entries = await collectEntries(pkg, cliEntryPath, exportPaths, cwd);
    const hasTypeScriptFiles = Object.values(entries).some((entry)=>isTypescriptFile(entry.source));
    if (hasTypeScriptFiles && !hasTsConfig) {
        const tsConfigPath = path.resolve(cwd, 'tsconfig.json');
        defaultTsOptions.tsConfigPath = tsConfigPath;
        await writeDefaultTsconfig(tsConfigPath);
        hasTsConfig = true;
    }
    const sizeCollector = createOutputState({
        entries
    });
    const entriesAlias = getReversedAlias(entries);
    const buildContext = {
        entries,
        pkg,
        exportPaths,
        cwd,
        tsOptions: defaultTsOptions,
        useTypeScript: hasTsConfig,
        pluginContext: {
            outputState: sizeCollector,
            moduleDirectiveLayerMap: new Map(),
            entriesAlias
        }
    };
    const buildConfigs = await buildEntryConfig(options, buildContext, false);
    const assetsJobs = buildConfigs.map((rollupConfig)=>bundleOrWatch(rollupConfig));
    const typesJobs = hasTsConfig ? (await buildEntryConfig(options, buildContext, true)).map((rollupConfig)=>bundleOrWatch(rollupConfig)) : [];
    const totalJobs = assetsJobs.concat(typesJobs);
    const result = await Promise.all(totalJobs);
    if (result.length === 0) {
        logger.warn('The "src" directory does not contain any entry files. ' + 'For proper usage, please refer to the following link: ' + 'https://github.com/huozhi/bunchee#usage');
    }
    if (!options.watch) {
        logOutputState(sizeCollector);
    } else {
        logWatcherBuildTime(result);
    }
    return result;
}
function runWatch({ input, output }) {
    const watchOptions = [
        {
            ...input,
            output: output,
            watch: {
                exclude: [
                    'node_modules/**'
                ]
            }
        }
    ];
    const watcher = rollup.watch(watchOptions);
    return watcher;
}
function logWatcherBuildTime(result) {
    let watcherCounter = 0;
    let startTime = 0;
    result.map((watcher)=>{
        function start() {
            if (watcherCounter === 0) startTime = perf_hooks.performance.now();
            watcherCounter++;
        }
        function end() {
            watcherCounter--;
            if (watcherCounter === 0) {
                logger.info(`Build in ${(perf_hooks.performance.now() - startTime).toFixed(2)}ms`);
            }
        }
        watcher.on('event', (event)=>{
            switch(event.code){
                case 'ERROR':
                    {
                        logError(event.error);
                        break;
                    }
                case 'START':
                    {
                        start();
                        break;
                    }
                case 'END':
                    {
                        end();
                        break;
                    }
            }
        });
    });
}
async function removeOutputDir(output, cwd) {
    const dir = output.dir;
    if (dir && dir !== cwd) await removeDir(dir);
}
function runBundle({ input, output }) {
    return rollup.rollup(input).then((bundle)=>{
        return bundle.write(output);
    }, catchErrorHandler);
}
function logError(error) {
    if (!error) return;
    // logging source code in format
    if (error.frame) {
        process.stderr.write(error.frame + '\n');
    }
}
function catchErrorHandler(error) {
    if (!error) return;
    logError(error);
    // filter out the rollup plugin error information such as loc/frame/code...
    const err = new Error(error.message);
    err.stack = error.stack;
    throw err;
}

exports.bundle = bundle;
